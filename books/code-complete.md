# Code Complete

[[toc]]

## クラスの作成

### Abstract Data Types: ADT

- ADT=データとそのデータに作用する操作をまとめたもの。
- クラス=ADT+継承+ポリモーフィズム

#### ADT を使うメリット

- 複雑な秘密（メンバデータ、実装の詳細）を持ち、それらを抽象化されたインターフェースからのみ操作する
- 抽象化されているのでわかりやすい、ひと目でわかる
  - `currentFont.attribute = 0x02` よりも `currentFont.setBoldOn()`
- 変更により影響が及ぶ範囲が小さくなる

#### ADT を使う時のガイドライン

- 下位レベルのデータ型を、上位レベルに抽象化する（現実世界の問題として扱う）
  - × 　スタック、リスト、キュー
  - ○ 　社員、請求書控え
- 単純な項目でも ADT として扱えば読みやすくなる
  - `light.on()`, `light.off()`

### 良いインターフェース

良いインターフェースは、良い抽象化と、良いカプセル化から成る。

#### 良い抽象化

- 抽象化のレベルを揃える
  - 例）社員というハイレベルな抽象化と、リストという下位レベルの抽象化が混在
  - `addEmployee()`
  - `RemoveEmployee()`
  - `firstItem()` -> `firstEmployee()`であるべき
  - `lastItem()` -> `lastEmployee()`であるべき
- インターフェースは対で提供することが多い
  - on - off
  - add - remove など
- 関係のない情報は別のクラスへ分離する
- インターフェースの変更・追加時にルールを逸脱しないよう注意する

#### 良いカプセル化

- カプセル化
  - 「実装の詳細を隠してしまうこと」
  - 具体的には、外部からのメンバルーチンへのアクセスを最小限にする。もちろんメンバデータは非公開にする。
- カプセル化の「意味的な違反」に注意する
  - プライベートな実装を意識してはならない。あくまでパブリックなインターフェースのみに依存すること。
  - クラスを使う時に内部実装を調べなければならないとしたら、それは抽象化に失敗したダメクラスである

### 設計と実装の問題

#### 包含(has a)

- クラスがメンバデータを保持している、ということ。
  - 社員（class） has a:
    - 名前
    - 電話番号
    - 社会保険番号
- クラスのメンバデータが 7 個を超えたあたりから、クラスを分解することを検討するとよい
- プライベート継承を使って'has a'を実現するな。親と子の結合度が高くなりすぎ、カプセル化に違反するから。
- プライベート継承とは、親の protected なメンバデータを子に継承することで、`has a`を実現すること。
- `is a`の関係でモデリングしたい場合を除き、通常は継承よりも包含のほうが望ましい。

#### 継承(is a)

- 子が、親の「特化」したバージョンではあるものの、基本的に同一である、ということ。
- 子は、親のインターフェースに **完全に** 従う。従わないとしたら、実装が正しくない。
- 継承は危険なテクニックである。継承するなら、きちんと設計とドキュメンティングを行い、できないならそのクラスの継承自体を禁止すること。
- Liskov substitution principle(LSP)に従え
  - 親で定義される全てのルーチンは、子でも全く同じ意味を持つこと
  - 子の種類によって意味が異なるとしたら、複雑さが増すだけで害しか無いから
- 親のオーバーライド不可能(private)なルーチンと同じ名前を子で使うな
- 共通のインターフェース、データ、振る舞いは、可能な限り継承の上位に移動する
- インスタンスが 1 つしかないクラスは消せ(るかも)
- 派生クラスが 1 つしか無い基底クラスは消せ
- ルーチンをオーバーライドしているのに中身が空のルーチンを見たら、親の設計を見直せ
- 子の種類は 7 つまで、階層は 3 つまでにとどめよ
- たくさんの条件分岐が出現したら、ポリモーフィズムの活用を検討せよ
- 多重継承は、mixin のために使うという意識で。例えば、`Displayable`と`Sortable`というインターフェースを実装するなど。

#### 包含と継承の使い分け

- 複数のクラスでデータのみ共通 → クラスを作成し、複数のクラスで包含する
- 複数のクラスでルーチンのみ共通 → 共通のルーチンを持つ基底クラスを作成し、複数のクラスで継承する
- 複数のクラスでデータ・ルーチンとも共通 → 共通のデータ・ルーチンを持つ基底クラスを作成し、複数のクラスで継承する

#### メンバルーチンとメンバデータ

- ルーチンの数は最小限に

#### コンストラクタ

- 全てのメンバデータを初期化せよ
- シャローコピーよりはディープコピーを優先して使え

### クラスを作成する理由

- 現実オブジェクト（車など）をモデリングする
- 抽象オブジェクト（四角形など）をモデリングする
- 抽象化の力により複雑さを緩和する
- 複雑さを分離する。一箇所直せばいい。
- 実装の詳細を隠蔽する
- 変更による影響を限定する
- 引数の受け渡しを減らす
  - 複数のルーチン間で引数をやり取りしている場合、その引数をメンバデータにもつクラスを作ることを検討する
- 制御を一元化する（DB 操作、ファイル操作、プリンタ操作など）
- コードの再利用を促進する
- 関連する操作をパッケージにまとめる（三角関数、文字列操作、ビット演算など）

#### 望ましくないクラス

- ゴッドクラス
- メンバデータしか持たないクラス
  - 他のクラスに移譲できないか検討する
- メンバルーチンしか持たないクラス
  - クラス名が動詞になったら要注意
  - DatabaseInitialization や StringBuilder といったクラスは、他のクラスのメンバールーチンであるべき

## 高品質なルーチン

ルーチン：関数、メソッドなど

### ルーチンを作成する理由

- 詳細について考える必要をなくすことで、複雑さを低減する
- 中間部分をわかりやすく抽象化する（`getConvertedName()`みたいな）
- 重複を排除する
- ルーチン(メソッド)を十分に分解し短く保つことで、サブクラスの作成を楽にする
- 複雑になりがちな、ポインタ関連処理を囲いだし、隠蔽する
- 移植性のない機能を囲だし、移植性を向上させる
- 複雑な論理評価（true or false）を囲いだし、単純にする
- 囲いだしたコードを 1 箇所改善することで、全体に効果が波及する

#### とても短いルーチンの扱い

1 行だけの単純なコードでも、場合によってはルーチンにしたほうが良い場合もある。

### ルーチンレベルでの設計

cohesion: 凝集度、強度。ルーチン内の処理がどれだけ密に関連しているかを表す。

下記の凝集度がある。先に記述したものほど理想的である。名前は覚えなくていいので内容を覚えること。

#### 機能的凝集度

最も高く、理想的な凝集度。ルーチンが一つの機能だけを提供する場合。id（入力データ）から名前を取得する`getCustomerName()`など。

#### 情報的（順序的）凝集度

ルーチンが決まった順序で実行する処理で構成される場合。生年月日（入力データ）から年齢を計算し、その年齢をもとに定年までの期間を計算する、など。

この凝集度を見つけたときは、2 つのルーチンに分離すること。

#### 連絡的凝集度

同じ入力データを使用するものの、全く別の処理を行う場合。報告書（入力データ）を印刷し、その後入力データを初期化する、など。

この凝集度を見つけたときは、2 つのルーチンに分離すること。

#### 時間的凝集度

ルーチンが、同じ時期に実行されるべきという点でのみ共通する機能を提供する場合。`startup()`,`shutdown()`など。

あくまで、他のルーチンを呼び出す指揮役として使う場合のみ使用が容認される。

#### 手順的凝集度(使うな)

画面に入力する順番と一致するから、というような理由で、一連のまとめられた機能を提供する場合。

#### 論理的凝集度（使うな）

引数のフラグにより処理を分岐させる場合。分岐させるという目的のために、特に関連の無いコードが凝集している状態。

フラグに応じて 3 種類の処理のいずれかを実行するのではなく、1 つの処理を実行する 3 種類のルーチンを作れ。

#### 暗号的凝集度（使うな）

もはやカオス。内部の機能に関係性がまるでないルーチンのこと。

### 良いルーチン名

名前をつけ辛いと感じた場合は、ルーチンの凝集度が低くないか疑うこと。

- 全ての **出力と副次効果** を名前に含める
- perform, output, process, deal など、意味がない or あいまいな動詞を使わない。
- 単なる数字を使わない
  - `outputUser1`
  - `outputUser2` など
- 多少長くても意味を理解するのに必要な長さにする。変数名よりは長くなりがち。
- 戻り値を表す
  - `printer.isReady()`
  - `customerId.Next()`
  - `pen.CurrentColor()` など
- 機能的凝集度であれば、オブジェクトを操作することが多いので、 **動詞＋オブジェクト名** の形にする
  - `PrintDocument()`
  - `checkOrderInfo()`など
  - ただしオブジェクト指向の場合はオブジェクト名は含めず、`document.Print()`,`orderInfo.Check()`などにする
- 正確な反意語を使う
  - add/remove
  - increment/decrement
  - open/close
  - begin/end
  - insert/delete
  - show/hide
  - create/destroy
  - lock/unlock
  - source/target
  - first/last
  - min/max
  - start/stop
  - get/put
  - next/prev
  - up/down
  - get/set
  - old/new

### ルーチンの長さ

長いとエラーが多くなるわけではないものの、目安は 200 行まで

### ルーチンの引数の使用

ルーチン間の値のやり取りのエラーは、エラー全体の 4 割を占める

- 引数の順序は、「入力するもの、変更するもの、出力するもの」の順に並べる
  - それらが区別できるような名前をつけるとなお良い
  - 特に、状態を呼び出し元に伝えたり、呼び出し元にエラーを通知するような引数は、一番最後にすること
- 複数のルーチンで似たような引数を使うときは、なるべく順序を統一する
- 使用しない引数は削除する
- 引数を変更しないこと。ローカル変数を使え。
- 引数に要件がある場合は明記する
  - 引数が「入力するもの、変更するもの、出力するもの」のどれに該当するか
  - 数値の単位
  - 期待される値の範囲
  - 期待していない値　など
- 引数は最大 7 個まで

### 関数とプロシージャ

#### 使い分け

関数とは、値を返すルーチンのこと

```go
id := customerID()
```

プロシージャとは、値を返さないルーチンのこと

```go
var report MyReport
var success boolean
formatReport(&report, &success)

if success == true { doSomething() }
```

- ルーチンの主な目的が、関数名が示す値を返すことであるなら、関数を使うこと
- それ以外の場合は、プロシージャを使うこと

#### 戻り値の設定

- 考えられる全ての`return`のパスを意識しておくこと。戻り値を関数の先頭で規定値に初期化しておくとよい。

## 防御的プログラミング

- Defensive Programming = 問題が起こることを前提とし、予め対策しておくこと
- 多すぎてもダメだし、少なすぎてもダメ

### 無効な入力への防御

- 外部ソースからのデータの値を確認する
- 入力引数の値を確認する
- 不正な入力を処理する方針を決定する

### アサーション

不正な値がないかを確認し、エラーがあれば大声でアサート（主張）すること。

- 入力引数の値が期待範囲内か
- ファイルがきちんと開けたか、ファイルの位置が先頭にあるか
- ポインタが null でないか　など

#### アサーション使用のガイドライン

- エラーとアサーションの使い分け
  - 発生しうる間違いにはエラーを使う
  - 発生してはならない状況にはアサーションを使う
- 事前条件と事後条件の文書化と検証に使う

### エラー処理テクニック

発生しうる間違い（エラー）が発生した場合に、どのように対処して続行するか

- 値を修正して処理を続行する
  - 当たり障りのない値を使う。ゼロ値やデフォルト値など。
  - 次の有効なデータで代用する。もう一回データを取得してみるなど。
  - 前回と同じ値を使う
  - 最も近い有効な値を使う
- ログに警告を残して、処理を継続する（必要に応じて他の案と組み合わせる）
- エラーをスローして、親が対処してくれるのを期待する
- グローバルなエラー処理の仕組みを作り、それに任せる
- エラーが発生した場所でエラーを表示する
- ローカルな範囲で、一番良いと思われる方法で処理してしまう
- 処理を中止する

#### 正当性と堅牢性

- 正当性：データが正確であること
- 堅牢性：ソフトウェアの実行が止まらないこと
- 正当性と堅牢性は背反する。コンシューマアプリでは堅牢性が重視される事が多い。

### 例外

例外のスロー（送出）は、「どう対処したらいいかわからない。誰か対処方法を知らない？」と叫ぶようなもの。上位のルーチンが例外を補足して対処するのが基本の流れである。

- 例外は、無視すべきでないエラーに使う。
- 例外は、他の（多くの場合、上位の）プログラムに伝達するためにつかう。
- 絶対に発生してはならないイベントで使用する（アサーションと同じ）
- ローカルで処理できるエラーを例外にするな
- コンストラクタ・デストラクタ内に例外を書くな（リソースリークの原因になる）
- 抽象化レベルを揃える（Employee クラスなら、EOFException ではなく、EnployeeDataNotFound にする、など）
- 例外メッセージには必要な情報を全て盛り込む
- 空のキャッチブロックは書かない
- 使用するライブラリがスローする例外を知っておく
- ログの記録、例外の報告を一元管理する仕組みを作るのもよい

### バリケードによるエラー被害の囲い込み

- 外部データは汚れているので、バリケードで消毒し、内部データを安全に保つ、という考え方
- 入力データは、可能な限り早い段階で正しい型に変換する
- バリケードの外側には、エラー処理を使用する（データのエラーが起こりうる）
- バリケードの内側には、アサーションを使用する（プログラムのエラーしかありえない）

### デバッグエイド

デバックを補助するコードや仕組みのこと。

#### プロダクション環境の制約を開発時には無視する

開発をスムーズに進めるために、開発環境に限って、リソースを大量に使う、実行が遅くなる処理を入れる、セキュリティを無視をする、などを行うことを検討する。

#### 早期導入

デバッグエイドの導入は早ければ早いほどよい

#### 攻撃的プログラミングの使用

開発段階で積極的に失敗を引き起こし、プログラムを中断してしまうことで、問題を洗い出しと修正を促すこと。

- アサーションでプログラムを中止して苦痛を伴わせ、問題を修正させる
- case 文の default 句で盛大に警告を出して失敗する　など

#### デバッグエイドの削除方法

- `make`など、バージョン管理ツールで行う
- `define`など、組み込みのプリプロセッサを利用する
- 独自のプリプロセッサを作成する
- デバッグエイド（ルーチン）を、製品版ではスタブに差し替える　など

### 製品コードに防御的プログラミングをどれくらい残すか

- 重要なエラーを検査するコードは残す
- 重要なエラーが発生したときは、プログラムを上品にクラッシュさせる
- 些細なエラーを検査するコードは削除する。または、エラーを記録するに留めるなどし、目立たなくする。
- 可能な限り、プログラムを中断するようなコードは控える（ユーザデータを失わないように）
- エラーメッセージを出す場合は、ユーザにわかりやすい言葉にすること

## 変数の使用

### 変数宣言・初期化のベストプラクティス

- 暗黙の宣言は無効にし、すべての変数を明示的に宣言する
- 宣言は使用場所の近くで行う
- 宣言時に初期化も行い、難しい場合はなるべく使用場所の近くで行う
- できるだけ final / const を使う
- カウンタ等、再初期化の必要がないか確認する

### スコープ

- スコープ = 変数の知名度
- 持続間隔 = 変数を利用する箇所の間隔
- 寿命 = 変数を宣言した場所から、最後に利用した場所までの距離

スコープを最小限にすることで下記の効果がある

- 一度に覚える必要のある情報が減り、読みやすくなる
- エラーが入りこむ余地が減る
- リファクタリングしやすくなる

#### スコープを小さくする方法

- 関連するステートメントをまとめる、あるいは別ルーチンに切り出す

```js
// Bad
show(OldData);
show(newData);
delete oldData;
delete newData;

// Good
show(OldData);
delete oldData;

show(newData);
delete newData;
```

- はじめは最も狭いスコープ（private など）にしておく

### 永続性

変数の永続性（賞味期限）を勘違いすると事故が起こる。対策は次の通り。

- 重要な変数に正しい値がセットされているか定期的に確認して、不正なら警告を出す
- 使い終えた変数に意味のない値を設定しておく
- データが永続的でないことを前提にコードを書く（変数はすべて使用直前に宣言する、そうでない変数には警戒する、など）

### バインディングタイム

変数に値を設定する時期のこと。数字が大きいほど柔軟性が高いが、複雑でエラーが起こりやすくなる相反関係にあるため、適当なところで折り合いをつける。

1. ハードコーディング
1. 定数でコーディング(ハードコーディングよりは常にマシ)
1. プログラムのロード時に環境変数などから読み込む
1. インスタンス生成時（ウィンドウ作成時など）
1. ジャストインタイム（ウィンドウ移動時など）

### 1 つの目的に 1 つの変数

- 変数を再利用しない
  - 例えば`temp`を同じスコープで、違う目的で回使わないこと。そうなった場合は、より具体的な 2 つの名前につけ直すこと。
- 変数に 2 つの意味や隠れた意味を持たせない（ハイブリッド結合しない）
  - 例えば、通常は人口（Integer）を表すが、-1 の場合はエラー(Boolean)を示す変数など。

## 変数名の力

変数名以外にも、クラス、パッケージ、ファイルなどにも適用可能。

### 良い名前にするための Tips

#### 名前はなるべく具体的にする

なにを表す変数なのか考える必要がない程度の具体的な名前にする。

- Good
  - runningTotal
  - trainVelocity
  - currentDate
  - linesPerPage
- Bad
  - ct
  - velt
  - x
  - lpp
  - lines
  - date

#### 問題を表す名前にする

- Good
  - employeeData
  - printerReady
- Bad
  - inputRecord
  - bitFlag

#### 最適な長さにする

8 文字～ 20 文字くらいが最もデバッグしやすいという研究がある

- 長すぎ => `numberOfPeopleOnTheUsOlympicTeam`
- 短すぎ => `n`
- ちょうどいい => `numTeamMembers`

#### 合計・平均・最大などを表す名前は変数名の最後につける

`Total`, `Sum`, `Average`, `Max`, `Min`, `Record`, `String`, `Pointer`など、計算した値を保持する変数には、その修飾子を最後につける。

例）

- revenueTotal
- expenceAverage
- expenceMax

ただし、`num`は例外なので要注意

- `numCustomers` => 顧客総数（'s'に注目）
- `customerNum` => 顧客番号

可能であれば`num`は使わずに下記のようにしたほうが良い。

- `customerTotal` => 顧客総数
- `customerIndex` => 顧客番号

#### わかりやすい反意語を使う

- begin / end
- first / last
- locked / unlocked
- min / max
- next / previous
- old / new
- opened / closed
- visible / invisible
- source / target
- source / destination
- up / down

### 特殊なデータの命名

#### ループ変数

ごく単純で、ネストされず、ループが 3 行以内で、ループの内部でのみ使用されるインデックスには、`i`,`j`,`k`といった名前を使っても良い。それ以外の場合は、通常と同じく、より具体的な名前をつける。

#### 状態変数

いわゆる「フラグ」のこと。意味のある名前をつける。必要に応じて定数も使う。

```txt
# BAD

flag = 0x1;
statusFlag = 0x80;
pringFlag = 16;

# GOOD

dataReady = true;
reportType = REPORT_TYPE_ANNUAL;
recalcNeeded = false;
```

#### 一時変数

`temp`や`x`などのこと。そもそも全ての変数は一時的なものである。`temp`という名前をつけたくなったときは、プログラマが問題を理解できていない可能性もある。より具体的な名前がつけられないか、よく検討すること。

#### ブール変数

- 有名どころを使う
  - done
  - error
  - found
  - success / ok
- true or false になる名前をつける
  - status => statusOK
  - sourceFile => sourceFileAvailable / sourceFileFound
- 頭に`is`をつけると正しい名前を矯正されるが、やや読みにくい
- 肯定的な名前を使う
  - notFound => found
  - notDone => done
  - notSuccessful => successful

#### 列挙型

`Color_Red`, `Color_Blue`のように、カテゴリを表すプレフィックスを付ける

### 命名規則の力

#### 命名規則を作る理由

どのような規約でも無いよりはまし

- 考えなくて済む
- 覚えたルールを他で活かせる
- 早く理解できる
- 名前の増殖を防ぐ
- プログラミング言語の弱点を補う

#### いつ命名規則が必要か

- 複数のプログラマがいる
- 誰かに引き継ぐことがある
- プロジェクトが大きい
- プロジェクトが長い　などの場合

#### どれくらい正式にするか

短小プロジェクトではゆるく、長大プロジェクトではきつく

### 短くて読みやすい名前

無理に省略するのは昔のなごりである。それでも省略したいなら、ガイドラインをまとめてプロジェクト内に周知しておくこと。

#### ガイドライン

変数が 8 文字～ 20 文字程度になるまで下記の作業を繰り返す

- 標準的な略記を使う
- 母音を削除する
  - computer => cmpter
  - screen => scrn
- and, or, the などを削除する
- '-ing', '-ed'などを削除する
- 名前の中で重要な単語を最大で 3 つ使用する
- 省略するなら 2 文字以上省略する
- 変数の意味を変えないように注意する

#### 省略するときの注意

- 省略法は一貫する
- 発音できる名前にする(xPos -> good, xPstn -> bad)
- 読み間違えなどを招く名前を避ける(bEnd -> good, bend -> bad)
- 書き手よりも読み手を大事にする。読み手に優しくない省略法は使うな。

### ダメな名前

- 意味が似た名前をいくつも使うな
  - `input` / `inputValue`
  - `recordNum` / `numRecord`
- 見分けにくい名前を使うな
  - bad => `clientRecs`/ `clientReps`
  - good => `clientRecords` / `clientReports`
- 名前に数字を使うな
- 綴りを勝手に変えない
  - bad => `hilite`
  - good => `highlight`
- 綴りを間違えやすい単語を使わない
  - `absence`
  - `accumulate`
  - `receipt`

## 基本的なデータ型

### 数値全般

- 0 と 1 だけは必要に応じてハードコーディングしてよい
- それ以外の数値（マジックナンバー）は使うな、名前付き定数を使え
- 0 除算が起きないよう注意する
- 型変換は明示的に行う
- 異なる型を（暗黙的変換で）比較しないこと

### 整数

- 除算に注意する　結果は言語により異なる(7/10===0 など)
- 桁あふれに注意する（中間結果、最終結果どちらも）

### 浮動小数点

- 大きさが極端に異なる数の加減算はするな
  - 結果が不正確になるから
  - もし行う場合は、数をソートしてから絶対値の小さい順に足していくと、最も誤差は小さくなる
- 等価を比較しない
  - 同じ値になるはずの 2 つの計算結果が、違う値になることはしばしば発生するため
  - もし比較したい場合は、ある程度の誤差を許容する、比較のためのルーチンを作成すること
- 丸め誤差に対処するには
  - 精度の高い方に変換する（単精度 → 倍精度）
  - BCD(Binary Coded Decimal)に変換する
  - 整数に変換する（ドルなら、105 を 1 ドル 5 セントとして管理するなど）
  - 丸め誤差に敏感な、専用の型が使っている言語に用意されていないか確認する

### 文字と文字列

- マジックキャラクタ・マジックストリングを使うな、名前付き定数を使え
- off-by-one エラーに注意する（文字列数を超えた読み取りなど）
- Unicode を使う
- 開発当初から i18n の戦略を練る
- C 言語における諸注意は省略、本書参照

### ブール変数

- 説明変数として使うことで、**評価を単純に**する。また、プログラムを **コードで文書化** する
  - `reachedToLastLevel = level === maxLevel`

### 列挙型

- コードを読みやすくするために使う

```js
// bad
result = getData(data, true, false, false);

// good
result = getData(
  data,
  EmploymentStatus_CurrentEmployee,
  PayrollType_Salaried,
  SavingsPlan_NoDeduction,
);
```

- 信頼性を高めるために使う（ありえない値をコンパイル時にチェック）
- 保守性を高めるために使う（実際の値が変更するときは 1 箇所を編集すれば OK）
- ブール値の代わりに使う（true ＋ 2 種類の false など）
- if/case で使う場合は、最後に無効な値を検査するのを忘れずに
- 実際に使用する要素以外の、制御用要素を使う
  - 列挙の最初と最後の要素をループ時に使用する
  - 最初の要素に無効な値を設定することで、未初期化の値を検出する

```cpp
enum Color {
  Color_InvalidFirst = 0, // 未初期化を検出
  Color_First = 1, // ループの最初の要素として使用
  Color_Red = 1,
  Color_Green = 2,
  Color_Blue = 3,
  Color_Last = 3, // ループの最後の要素として使用
}
```

- 言語に enum が存在しない場合は、自分で作ること

## ストレートなコードの構成

### 順序が重要なステートメント

順序（依存性）がわかる書き方をすること。

- コード構成、ルーチン名で表す
  - 例えば、初期化を行うルーチンなら、`ComputeMarketingExpense`ではなく`InitializeExpenceData`など
- ルーチンの引数を使って表す

```py
# good（順序が大事であることがわかる）
data = initialize(data)
data = compute(data)
data = finalize(data)

# bad(順序が大事であることがわからない)
computeMarketingExpence()
computeSales()
computeExpence()
```

- コメントで説明する（最後の手段）

### 順序が重要でないステートメント

コードが実行順序に依存しない場合は、関連する作業をできるだけ近くに配置すること。

#### 上から下へ読めるコード

読むべき場所が散在しているコードは悪いコードである。なるべく関連するものを一箇所にまとめること。[変数の寿命を短くする](#スコープを小さくする方法)のは効果的。

#### 関連するステートメントのグループ化

関連するステートメントを四角で囲ってみて、四角形が交錯するなら、うまくまとまっていないといえる。

## 条件文の使用

### if

#### if-then を書く場合の注意

- 正常系の実行パスを、読みやすいように最初に書く。異常系の処理によって読みにくくなることがないようにする。
- 異常系は原則として else 文に書く。
- else 句は不要な場合が多いので疑ってかかること
- off-by-one エラーに注意する。`<`と`<=`の書き間違いなど。

#### if-then-else の連鎖を書く場合の注意

- 複雑な条件式はルーチンに切り出してカプセル化する（`isAlphabet()`など）
- もっとも一般的なケースをより上位に書く
- case 文で代用できないか検討する

### case

#### 順番

下記の中から一番適切なものを選択する

- アルファベット順・数値順
- 正常系と異常系の 2 つしかない場合は、正常系を先頭にする
- 出現頻度順

#### その他

- 各ケースの処理は短く書く。長くなるならルーチンに切り出す。
- 簡単に分類できる単純なデータにのみ使用する。分類作業が複雑になるなら if 文を使う。
- default 句では「その他」扱いのものだけを扱う、または「エラー処理」に使う
- fallthrough は使うな。使うなら、必ずコメントを残せ。

## ループ

- ループは複雑である。単純に保つよう努力せよ。
- 変わったループを作らない
- ネストをできるだけ少なくする
- 入口・出口を明確にする
- 前処理・後処理を一箇所にまとめる
- ループ変数には良い名前をつけ、1 つの目的で使う
- 全てのケースで正常に実行され、どんな条件でも終了することを検証する

### ループの種類

- カウント：決められた数だけ
- 連続評価：ループ毎にどうするか判定
- エンドレス：永遠に
- イテレータ：イテレーションが終わるまで

#### while-break

- `while-break`を使うと、ループの最初や最後ではなく **途中** に出口があるループを作ることができる。
- ただし、ループ内部のコードを見ないと終了条件がわからないというデメリットがある。
- 下記のように、重複処理を避けるために使うとよい。

```js
// bad
doSomething1();
doSomething2();
while (score < 10) {
  other();
  doSomething1();
  doSomething2();
}

// good
while (true) {
  doSomething1();
  doSomething2();
  if (score < 10) break;
  other();
}
```

#### for

- 単純な処理にのみ使用する
- ループを途中で抜けたいなど、制御が複雑なループには`while`を使用する
- ループを途中で抜けたいがために、ループ変数を変更してはならない

#### foreach

- ループを繰り返すための計算が不要であるため、エラーの原因を減らせる

### ループの制御

ループに関する問題を防ぐためのベスト・プラクティス

- ループに影響する要因を最小限にする（単純にする）
- ループの内部をブラックボックスにする
  - ループの内部をルーチンとして考える
  - 制御に関わる変数などを、なるべくループの外に出す

#### ループの開始

- 入り口は 1 箇所にする
- 初期化コードをはループの直前に書く（近接の法則）
- for のヘッダにループ制御に関係ないコードを詰め込まない

#### ループ本体

- 本体が空のループは作るな、書き直せ
- 前処理・後処理(`i++`など)は、ループの先頭か末尾にまとめる
- ループ内の処理は 1 つの機能に絞る
  - 単一責任の法則。ルーチンと同じと考えよ。
  - とりあえず分けて作成し、パフォーマンスの問題が出てからまとめる、で OK

#### ループの終了

- どんな場合でもループが終了することを確認する
- 終了条件を明確に記載する
- for において、ループ変数を書き換えない
- ループ変数の最終値を使用するな。必要ならループ外の変数に明示的に値を保存しておけ。
- 安全カウンタ（上限）を適宜使用する
- while ループでは、フラグよりも break を使うときれいになりやすい。ただし、複数の break には要注意。
- continue は先頭で使う。中盤以降で使う場合は替わりに if 文を使うこと。
- continue, break は注意して使う（終了条件を知るには内部を見る必要があり、ブラックボックスではなくなってしまうから）

#### ループ変数の使用

- ごく単純なループを除き、ループ変数には`i`などの意味のない名前ではなく、`carNumber`など意味のある名前をつける。特にネストする場合は。
- ループ変数は、ループ内のみをスコープにする（コンパイラに頼らないこと）

#### ループの適切な長さ

- 最長でも 1 画面で確認できる程度の短さにする
- ネストは最大でも 3 段階まで
- 長くなりすぎる場合はルーチンに切り出す
- 長いループでは、出口や終了条件を特にシンプルにすること

### ループの作成

ループ内部から、外側に向けて作成していくと良い

### ループと配列

配列をループ処理する場合は、`foreach`や`map`を積極的に使用する。それにより、ループにまつわる様々な問題を減らすことができる。

## 特殊な制御構造

### ルーチンからの複数の return

読みやすくなる場合を除き、return の使用は最小限に抑える。

- コードを読みやすくするために使う
  - 答えがわかった時点で制御を呼び出し元に戻すことで、読みやすくなる場合がある
- ガード句を使って複雑なエラー処理を単純化するために使う
  - 前提条件を満たしていない場合などは、ルーチンの頭で return することで深いネストを避けることができる

### 再帰

- 問題の範囲が狭い時に使うのが最適である。
- 多くの場合、単純にスタックと繰り返し構造を使ったほうが理解しやすい。

#### ヒント

- Base Case を必ず作る
- 安全カウンタを作って無限再帰を防ぐ
- 再帰の中から別の種類の再帰を呼ばない（ルーチンは 1 つに限定する）
- 再帰を使う必要のないものに使わない（階乗やフィボナッチ数列など）

### goto

ほぼすべての goto は他の制御構造に書き換えられる。よほどの理由がない限り使わないこと。

## テーブル駆動方式

- 複雑なロジック（if|case）や、複雑な継承構造を劇的にシンプルにできる
- もしテーブルデータを外部に保存すれば、コードを変更せずにデータを修正できる

例えば`inputChar`という変数の種類を判定したい場合、テーブルを使うと、複雑な`if`文を使わずにすむ。

```js
charType = charTypeTable[inputChar];
```

### 検討すべき事項

- 参照方法をどうするか
  - 直接アクセス
  - インデックスアクセス
  - 段階型アクセス
- 何を格納するか
  - データ
  - ルーチン

### 直接アクセス方式

特定の値をキーとしてテーブルにアクセスする方法。目的の要素に一発でアクセスできる。

```js
// 指定した月の日数を求める
daysOfMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
days = getDaysOfMonth(someMonth - 1); // 関数ではなく単純にArrayで実装してもOK

// 保険料率を予め用意した表から取得する
rate = rateTable(smokingStatus, gender, maritalStatus, age);
```

#### 参照キーの補正

例えば「年齢」をキーにするものの、18 歳以下は全て同じデータを返したい場合など、
参照に使うデータをそのままキーとして使えない。このような場合は、以下の方法でキーの補正が必要になる。

- テーブルを複製する方法
  - 1 から 18 歳までのテーブルに全て同じデータを複製する。
- キーを変換する方法
  - ルーチンを使う `keyFromAge(age)` で 18 歳以下のキーを 18 に変換
  - ハッシュを使う `keyFromAge[age]` で 18 歳以下のキーを 18 に変換

### インデックスアクセス方式

単純な数値変換では、テーブルのキーを取得できない場合に使う。
（多くの空要素を容認した）インデックスを生成することで、散在したデータを上手く扱うことができる。

例）100 種類の商品を 0 から 9999 までのランダムな番号で管理している場合：

- インデックステーブル
  - 10000 個の配列
  - ほとんどは空要素
  - 詳細データへの参照を持つ
- 詳細データを含むテーブル
  - 実在する商品のデータのみ保持

下記のメリットが有る

- メモリ消費を減らせる
- 低コストに検索が可能、好きなだけインデックスを作れる
- 保守性が高い

### 段階型アクセステーブル

インデックスアクセス方式では対応できない、不規則なデータや、きりの悪いデータに適している。
特定の値ではなく、範囲をキーとしてテーブルにアクセスする。

```go
// スコアをキーに変換する
func getLevelByScore(score float64) int {
  rangeLimits := []float64{50.0, 65.0, 75.0, 90.0, 100.0}
  maxLevel := len(rangeLimits) - 1

  for level, limit := range rangeLimits {
    scoreInRange := score <= limit
    reachedToLastLevel := level == maxLevel
    if scoreInRange || reachedToLastLevel {
      return level
    }
  }
  panic("this can't be happen")
}

func main() {
  gradeNamesByLevel := []string{"E", "D", "C", "B", "A"}

  fmt.Println(gradeNamesByLevel[getLevelByScore(85.1)]) // => "B"
}
```

#### 注意点

- 終端・境界の処理が正しいか確認する
- 必要に応じて、リニアサーチではなくバイナリサーチを使う
- インデックスアクセス方式の利用を検討する（特にスピードが重要な場合）
- キーの計算はルーチンとして独立させること

## 制御構造の問題

### 論理式 (boolean expression)

全ての制御は論理式を使う。

#### true or false を使って読みやすく

- 論理式には`true`or`false`を使う。0 や 1 は使うな。
- 論理式（ブール値）の比較には、暗黙の照合を積極的に使え。
  - `done === false`よりも`not done`
  - `(a>b) === true`よりも`a>b`

#### 複雑な式は単純化する

複雑な式は単純化する。ポイントは、**コードで文書化**すること。

- 中間値を、良い名前の説明変数に代入することで読みやすくする
- 良い名前をつけたブール関数として独立させる
- if や case ではなく決定表（テーブル駆動方式）を使う

#### 肯定的な論理式にする

否定文の繰り返しは非常に理解しにくい。

- if の条件が否定文（`!statusOK`）の場合は、if 句と else 句を交換する
- ド・モルガンの定理を利用して、複数の否定を単一の否定にまとめる。
  - `not A or not B` => `not (A and B)`
  - `not A and not B` => `not (A or B)` (これは微妙かも)

#### カッコを使って明確化する

計算の優先順が曖昧な場合は、カッコを使って読みやすくする

#### 式が評価される方法を知っておく

評価の方法は言語によって異なる

- `A or B`において、`A`が真なら`B`は評価しないという言語が多い。
- ただ、そうでない言語もあり、場合によってはエラーを引き起こす原因になる。
- 読み手を混乱させる可能性がある場合は、ネストさせることで意図を明確にしておくこと。(`if(A){ if(B){} }`)

#### 数値を含む式は数直線の順に並べる

- `i > MIN and i < MAX` => bad
- `MIN < i and i < MAX` => good

#### 0 との比較

0 は複数の目的で使用されるため、目的を強調するようにコードを書くこと。

- 論理式（ブール値）は暗黙に比較する `if (!done)`
- 数値は 0 と比較する `count != 0`
- ポインタは null と比較する
  - `if(bufferPtr)` => bad
  - `if(bufferPter == null)` => good

### 深いネストの回避

例えば、3 レベル以上の if 文を理解できる人はほぼいない。

以下、if 文の深いネストを回避する方法。

- 早めに return 又は break する（関数内などに限る）
- if-then-else に置き換える（効率的な順番で評価し、評価を無駄に繰り返さないこと）

```js
if (i > 100) {
} else if (i > 10) {
} else {
}
```

- case に置き換える

```js
switch (true) {
  case i > 100:
    break;
  case i > 10:
    break;
  default:
}
```

- ネストしたコードをルーチンに切り出す
- 設計を見直す。多くの場合、単純に理解が足りていないだけの場合が多い。

### 構造化プログラミング

- 入口が一つ、出口が一つの制御構造を使用すべき、という考え方。
- 構造化されたプログラムは、規則的な方法でプログラムが進む。上から下に読んでいける。
- コードの最も詳細なレベルの話である。構造化されたトップダウン形式の設計のことではない。

#### 3 つの要素

構造化プログラミングでは下記の 3 つの制御構造のみを使用する。
これ以外の制御構造（`break`,`continue`,`return`,`throw-catch`,`goto`など）が使われていたら批判的に見ること。

- 連続　順番に実行されるステートメントの集合
- 選択　 if や case など
- 反復　 for や while など

### 制御構造と複雑さ

- 制御構造の使い方は、プログラム全体の複雑さを大きく左右する。
- 複雑さとは
  - コードを理解するのに必要な労力
  - 頭の中に一度に整理しなければいけない事柄の数

#### ガイドライン

- 複雑さを「判定ポイント」で定量化する
  - `if`,`while`,`for`,`and`,`or`ごとに 1 と数える
  - `case`の選択肢ごとに、1 と数える
  - 6 を超えたら批判的に見る
