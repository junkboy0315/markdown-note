# シェル・ワンライナー 160 本ノック

Tags: Linux, Shell

## まとめ

### general

- ファイルの内容を調べる
  - `file some_image.jpg`
- 実行時間を計測する
  - `time ワンライナー`
- コマンド置き換え
  - `$(コマンド)`
  - コマンドの実行結果を引数として使うことができる
- for文
  - `for(i=1;i<$1;i++)printf(" ")`

### seq

順番に数値を出力する。

```sh
# 昇順
seq 5

# 降順
seq 5 1
```

### sed

- 入力データに置き換え処理を施したうえで再出力する
- `-n`オプションをつけると、処理対象となった行のみを出力する

#### 置き換え(`s///`のパターン)

- 一回だけ置き換える

```bash
echo あいうえおあいうえお | sed 's/あ/か/'
# かいうえおあいうえお
```

- 何回も置き換える(`g`)

```bash
echo あいうえおあいうえお | sed 's/あ/か/g'
# かいうえおかいうえお
```

- 複数の置き換え条件を指定するには`;`で区切る

```bash
echo あいうえおあいうえお | sed 's/あ/か/g;s/い/き/g'
# かきうえおかきうえお
```

- 検索対象の文字を使う(`&`)

```bash
echo クロロエチルエーテル | sed 's/エチル/&&/'
# クロロエチルエチルエーテル
```

- 後方参照(`\1`や`\2`など)
  - `-E`は拡張正規表現を有効にする
    - `-r`でも同じ意味
    - 無駄にエスケープ文字を入れなくて済むようになる
    - 基本正規表現だけ使えればいいなら不要

```bash
echo クロロエチルメチルエーテル | sed -E 's/(エチル)(メチル)/\2\1/g'

# 以下のようにもかける
echo クロロエチルメチルエーテル | sed -E 's/(エ..)(...)/\2\1/g'
```

#### 検索(`//p`のパターン)

```sh
sed -n '/正規表現/p'

# 期間抽出（正規表現1に一致する行から、正規表現2に一致する行までを出力する）
sed -n '/正規表現1/,/正規表現2/p'
```

### grep

- デフォルトで正規表現が使える
- 入力は 1 行ごとでも、スペース区切りでも OK

```bash
# 0を含むもの
seq 100 | grep "0"

# 8で始まるもの
seq 100 | grep "^8"

# 8で終わるもの
seq 100 | grep "8$"

# 80台
seq 100 | grep "8."

# 1, 10, 100, ...
seq 100 | grep "^10*$"

# 偶数
seq 100 | grep "[02468]$"

# 奇数
seq 100 | grep "[^02468]$"
```

- `-o`オプション
  - マッチした部分のみが出力される
  - 複数行で出力される

```bash
# 山田と上田
echo 中村 山田 田代 上田 | grep -o '[^ ]田'
```

- `-l`オプション - 一致した部分ではなくファイル名を出力する
- `-R`オプション - ディレクトリ内のファイルを再帰的に読み込む
- `grep some_pattern ./*` - 特定のディレクトリ内のファイル内容を検索

### awk

- grep にプログラム機能を加えたもの
- `awk '/正規表現/'`の書き方にすれば正規表現が使える
- `$0`は「すべての列（行全体）」を表す
- `$1`は「１列目の文字列 or 数値」を表す
  - データの n 列目を「第 n フィールド」と呼ぶ
- `print`は自動的に間のスペースと行末の改行を入れてくれる。awk ではよく使う。
- 構成要素
  - Pattern
    - 抽出条件のこと
    - 正規表現 or 計算式
    - e.g. `$1%2==0`, `/[a..b]/`
  - Action
    - 処理のこと
    - `{}`で囲まれている
    - e.g. `{print(...)}`
    - デフォルトはprint
  - Rule
    - パターンとアクションの組み合わせのこと
  - パターンだけ、アクションだけでも実行可能

```bash
# 正規表現で抜き出す
seq 5 | awk '/[24]/'

# 計算で抜き出す
seq 5 | awk '$1%2==2'

# マッチした行に処理を加える(以下の２つは等価）
seq 5 | awk '$1%2==0{printf("%s 偶数\n", $1)}'
seq 5 | awk '$1%2==0{print($1,"偶数")}'

# 2つ以上のルールを使う
seq 5 | awk '$1%2==0{print($1,"偶数")}$1%2==1{print($1,"奇数")}'

# 三項演算子を使う
seq 5 | awk '{print($1%2==0 ? "奇数" : "偶数")}'
```

- 期間抽出
  - 正規表現1に一致する行から、正規表現2に一致する行までを出力する

```sh
awk '/正規表現1/,/正規表現2/'
```

- 列の結合（と比較）

```sh
awk '$1$2=="abcd"'
#`$1" "$2`は$1と$2をスペースでつなげたものになる
awk '$1" "$2=="abcd"'
```

- `-F`オプション
  - 区切り文字を明示的に指定する
  - `awk -F:` だとコロンが区切りになる
  - デフォルトはスペース
- 組み込み変数
  - `NF` - 総フィールド数
  - `NR` - 行番号

#### Pattern, Action のどちらでも利用可能なもの

- 比較
  - `$1<"20191001`
- Regex
  - `$2~/REGEX_PATTERN/`
- orは`||`

#### Pattern

- BEGIN パターンは最初の行の処理前に実行される
- 無名のパターンは全ての行で実行される
- END パターンは最終行の処理後に実行される

```bash
awk 'BEGIN{a=0}{a+=1}END{print a}'
```

#### Action

- 三項演算子で条件分岐

```sh
awk '{print ($1<12?"午前":"午後")}'
```

- 三項演算子で条件分岐(列を追加する)

```sh
awk '{tax=($1<"20191001")?1.08:1.1;print $0,tax}'
```

- 一つのアクション内で２つのコマンドを実行したいときは`;`で区切る。

```sh
awk '{printf("a");printf("b")}'
```

- 列の値で計算する

```sh
awk '{print int($3*$4)}'
```

### xargs

- 入力を横に並べて、出力する
  - デフォルトでは`echo`が指定されたものとみなされる
- 入力を横に並べて、コマンドに **引数(入力ではない)** として渡したうえ実行してもらう
  - 本来の使い方

```sh
seq 4 | xargs mkdir # => `mkdir 1 2 3 4`になる
seq 4 | xargs rmdir # => `rmdir 1 2 3 4`になる
```

- 決まった数ずつコマンドに渡していく

```sh
seq 4 | xargs -n2 mv
# `mv 1 2`と`mv 3 4`になる
```

- 下記のように数個ずつ画面出力するのにも使える。
  - この際空行は削除される
  - セキュリティには注意すること

```sh
seq 10 | xargs -n5
```

- 入力を改変してコマンドに渡す(@マークは別の文字に変えてもOK)

```sh
seq 4 | xargs -I@ mkdir dir_@
```

- 並列実行する

```sh
xargs -P4 SOME_COMMAND
```

### bc

計算をするために使う。

```bash
echo '1+1' | bc
```

### sort, uniq

- データの中に何がいくつあるのか数えるときは、「sort で並び替えて uniq で数える」のが鉄板
- なぜ sort が必要なのか？
  - uniq に与えられるデータはソートされていることが前提のため（一つのことだけやる。プログラムを簡素にする。UNIX 的な思想。）

```bash
seq 5 | awk '{print($1%2==0 ? "奇数" : "偶数")}' | sort | uniq -c
```

```sh
# 2列目から2列目を使って辞書順でソート(10 then 1)
sort -k2,2

# 2列目から2列目を使って数値順でソート(1 then 10)
sort -k2,2n
```

### 標準入出力

- しっかりしたコマンドは
  - 別のコマンドに渡すべきデータを**標準出力**から出す
  - 別のコマンドに渡すべきでないデータを**標準エラー出力**から出す
- デフォルトでは
  - 標準出力と標準エラー出力は**端末画面**につながっている
  - 標準入力は**キーボード**につながっている
- ファイル記述子（ファイルディスクリプタ）
  - `0` - 標準入力
  - `1` - 標準出力
  - `2` - 標準エラー出力

標準出力のリダイレクト

```sh
test.sh > file.txt
test.sh 1> file.txt
```

標準エラー出力のリダイレクト

```sh
test.sh 2> file.txt

# stderrの出力先を、いまstdoutがつながっている先に振り向ける（マージされる）
test.sh 2>&1

# パイプを使った方法（stdoutのみならずstderrも渡される）
test.sh |& cat
```

標準入力のリダイレクト

```sh
cat < file.txt
cat 0< file.txt

# 番外編）catとpipeを組み合わせる方法
cat a.txt | wc -l

# 番外編）引数にファイル名を指定
wc -l a.txt
```

### 変数

値のセット

- スペースを入れてはだめ(コマンドとして解釈されるから)

```sh
a=ほげほげ
```

値の利用

- コマンドが**実行される前**に変数が文字列に入れ替わる

```sh
$a
${a} # この書き方が必要になることもある。変数名のあとに文字を続けたい場合など。
```

文字列操作

- `${a//}`や`${a::}`などはParameter Expansion(変数展開)と呼ぶ

```sh
a=あいうえお
b=かきくけこ

# 結合
echo $a$b # あいうえおかきくけこ

# 追加（破壊的）
$a+=$b ; echo $a # あいうえおかきくけこ

# 開始位置と長さ
echo ${a:1:3} # いうえ

# 置き換え
echo ${a/えお/けこ} # あいうけこ
```

計算

- 算術式展開`$(())`を使う
  - 変数利用時の`$`は不要
  - 扱えるのは整数のみ

```sh
a=6
b=2
echo $((a+b)) # 8
```

クォート

- シングルクォート
  - 変数(`$1`など)をシェルで解釈せずに、そのままコマンドに渡す
  - 空白の入った引数をひとまとめにして引き渡す
    - e.g. awkの`'{print 1+1}'`など
- ダブルクオート
  - 変数がシェルで解釈される
  - シェルスクリプトでは変数はダブルクォートの中に配置するのが無難
    - 変数の中身が空文字だと、なかったものとして扱われるため

```sh
re=""

grep "$re" /etc/passwd # ok
grep $re /etc/passwd # grep /etc/passwd と解釈されるため不正
```

## ログ

### 1.2.a 端末を使う

- プロンプト - `$`マークのこと
- コマンド - `echo $0`のようなもの
- シェル - ソフトウェアのこと
  - プロンプトを出したり、コマンドを受け取ったりしている
  - bash はシェルの名前
- 端末 | terminal
  - 遠くにあるコンピュータと接続して作業するのに使う機械のこと
  - 元々は本当に機械だった
    - データをコンピュータに送信し、返ってきたデータを印字出力するなど
  - 今はエミュレータ

### どこだったかな

- `|` - パイプ。左の結果を右に渡す。
- 以下の通り、コマンド関連の用語はあいまいである
  - コマンド
    - 1 単語の場合はコマンドとして用いられるソフトウェアのこと
      - e.g. `bc`、`echo`
    - 2 単語以上の場合はシェルの受け付ける命令のこと
      - e.g. `echo $0`
  - ワンライナー - コマンドを 2 つ以上組み合わせたもの
  - パイプライン - パイプにコマンドがつながったもの
  - コマンドライン - 打ち込んだ 1 行分の命令

### 1.2.b コマンドの止め方

- `Ctrl + C` - 強制終了。非常によく使う。
- `Ctrl + D` - 端末にこれ以上ユーザが入力するものがないことを伝える。次点としておぼえておけば OK。

### 1.2.d ファイルへの保存

```bash
echo '1+1' | bc > result.txt
```

- `>`は、リダイレクト記号という

### 1.2.e ファイルとディレクトリの操作

```bash
echo あいうえお > somefile
mkdir tmp
mv somefile tmp/
# tmpフォルダの内容を一覧
ls -l tmp/
rm tmp/somefile
rmdir tmp/
```

### 1.2.f ファイルのパーミッション

```bash
chmod -r somefile
chmod +r somefile
```

- パーミッション
  - ファイルの所有者
  - ファイルの所有グループ
  - それ以外
- `sudo`を毎回するのが面倒なときは`sudo -s`

### 1.2.g コマンドの調査

man は章立てになっている。たいていは 1 章に求めるものが書いてある。

```bash
man some_command

# 5章を見る
man 5 some_command
```

該当行とその次の１行を出力する

```bash
man ls | grep -A 1 '^  *-a'
```

### 1.3.g bash によるメタプログラミング

```sh
seq 4 | awk '{print "mkdir " ($1%2==0 ? "even_" : "odd_") $1 }' | bash

# 以下の４つのフォルダが作られる
# mkdir odd_1
# mkdir even_2
# mkdir odd_3
# mkdir even_4
```

- シェルスクリプトとは
  - シェルにやってもらいたいことを順番に書いたファイル
  - `bash ./somefile`で実行できる
- シェルスクリプトをコマンドとして使うには
  - １行目に shebang(`#!/bin/bash`)を入れる
    - OS が shebang に書いたコマンドを呼び出し、そのコマンドが 2 行目以降を読み込むよう手配される
  - ファイルに`chmod +x`で実行権限を与える
  - これで`./somefile`で実行できるようになる

### Q1 ファイル名の検索

テキストファイルからの抽出の例：

```sh
# 王道
cat ./qdata/1/files.txt | grep '\.exe$'
cat ./qdata/1/files.txt | awk '/\.exe$/'

# - `-n`は各行を自動的に出力しない
# - `/正規表現/p`でマッチする行だけ出力する
cat ./qdata/1/files.txt | sed -n '/\.exe$/p'
```

### Q2 画像ファイルの一括変換

あるフォルダ内にある png ファイルを全て jpg 形式に変換する方法

```sh
# 私の回答
ls *.png \
| sed -E 's/(.*)\.png$/\1/g' \
| awk '{print "convert " $1".png " $1".jpg"}'
| bash

# 鮮やかな回答
ls *.png | sed 's/\.png//' | xargs -I@ convert @.png @.jpg
```

```sh
# 発展型(時間計測と、並列実行による高速化)
time ls *.png | sed 's/\.png//' | xargs -P$(nproc) -I@ convert @.png @.jpg
```

### Q3 ファイル名の一括変更

`1`から`10000`までのファイルがあるとして、0 埋めにファイル名を変更せよ

```sh
seq 1000 | xargs -P2 touch

ls | awk '{printf("%d %04d ",$1,$1)}' | xargs -n2 mv
```

### Q4 特定の内容のファイルを探す

```sh
grep -l -R MY_FINDING_STRING | xargs rm
```

### Q5 設定ファイルからの情報抽出

```sh
# 私の回答
cat ntp.conf | awk '/^pool/{print $2}'

# 模範解答
cat qdata/5/ntp.conf | awk '$1=="pool"{print $2}'
```

### Q6 端末に模様を書く

```sh
# 回答例１
seq 5 | awk '{for(i=1;i<$1;i++)printf(" ");print "x"}' | sort

# 回答例２
seq 4 0 | awk '{for(i=$1;i>0;i--)printf(" ");printf("x\n")}'
```

### Q7 消費税

```txt
20190901 ゼロカップ大関 10000
20190902 *キャベツ二郎 130
20191105 外食 13000
20191106 ストロングワン 13000
20191106 *ねるねるねるねる 30
20190912 外食 13000
```

```sh
cat qdata/7/kakeibo.txt | \
awk '{tax=($1<"20191001"||$2~/^あ/)?1.08:1.1;print $0,tax}' | \
awk '{print int($3*$4)}' |
awk '{sum+=$1}END{print sum}'
```

### Q8 ログの集計

```txt
183.YY.129.XX - - [07/Nov/2017:22:37:38 +0900]
192.Y.220.XXX - - [08/Nov/2017:02:17:16 +0900]
66.YYY.79.XXX - - [07/Nov/2017:14:42:48 +0900]
::1 - - [07/Nov/2017:13:37:54 +0900]
133.YY.23.XX - - [07/Nov/2017:09:41:48 +0900]
```

```sh
cat qdata/8/access.log | \
awk -F: '{print $(NF-2)}' | \
awk '{print ($1<12?"午前":"午後")}' | \
sort | \
uniq -c

# awkのところの別解。こっちが直感的かも。
grep -o "....:.." | sed s/....://
```

### Q9 期間抽出

```sh
# sed
qdata/9/log_range.log | sed -n '/24\/Dec\/2016 21:..:../,/25\/Dec\/2016 03:..:../p'
# awk
qdata/9/log_range.log | awk '/24\/Dec\/2016 21:..:../,/25\/Dec\/2016 03:..:../'
```

### Q10 マークダウンの変換

```sh
cat qdata/10/headings.md | \
sed -E 's/^# +(.*)/\1\n===/g' | \
sed -E 's/^## +(.*)/\1\n---/g'
```

### Q11 議事録の整理

```sh
cat qdata/11/gijiroku.txt | \
xargs -n2 | \
sed 's/すず/鈴木/g;s/さと/佐藤/g;s/やま/山田/g;s/ /: /g'
```

### 練習2.1.a

